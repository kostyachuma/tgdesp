{"version":3,"sources":["webpack:///./src/lib/appManagers/appStateManager.ts"],"names":["STATE_VERSION","version","STATE_INIT","allDialogsLoaded","pinnedOrders","contactsList","updates","filters","maxSeenMsgId","stateCreatedTime","Date","now","recentEmoji","topPeersCache","recentSearch","authState","_","hiddenPinnedMessages","settings","messagesTextSize","sendShortcut","animationsEnabled","autoDownload","contacts","private","groups","channels","autoPlay","gifs","videos","stickers","suggest","loop","emoji","big","themes","name","background","type","blur","slug","highlightningColor","color","theme","notifications","sound","keepSigned","chatContextMenuHintWasShown","stateId","ALL_KEYS","Object","keys","REFRESH_KEYS","AppStateManager","super","log","neededPeers","Map","singlePeerMap","storages","users","chats","dialogs","storagesResults","storage","this","loadSavedState","loaded","console","time","Promise","resolve","storagesKeys","storagesPromises","map","key","getAll","promises","get","concat","all","then","arr","state","i","length","value","undefined","pushToState","splice","auth","shift","shiftedWebKAuth","push","values","dcID","baseDcId","date","id","obj","forEach","idx","set","dispatchEvent","preserve","state_id","s","r","hasOwnProperty","nightTheme","find","t","missingKey","timeEnd","catch","first","split","direct","setKeyValueToStorage","peerId","limit","has","Set","add","keepPeerSingle","existsPeerId","delete","size","appStateManager"],"mappings":"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","file":"26.b0731fe124402f15f1bb.chunk.js","sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type { Dialog } from './appMessagesManager';\nimport type { UserAuth } from '../mtproto/mtproto_config';\nimport type { MyTopPeer, TopPeerType, User } from './appUsersManager';\nimport type { AuthState } from '../../types';\nimport type FiltersStorage from '../storages/filters';\nimport type DialogsStorage from '../storages/dialogs';\nimport EventListenerBase from '../../helpers/eventListenerBase';\nimport rootScope from '../rootScope';\nimport stateStorage from '../stateStorage';\nimport { logger } from '../logger';\nimport { copy, setDeepProperty, validateInitObject } from '../../helpers/object';\nimport App from '../../config/app';\nimport DEBUG, { MOUNT_CLASS_TO } from '../../config/debug';\nimport AppStorage from '../storage';\nimport { Chat } from '../../layer';\nimport { IS_MOBILE } from '../../environment/userAgent';\nimport DATABASE_STATE from '../../config/databases/state';\nimport sessionStorage from '../sessionStorage';\nimport { nextRandomUint } from '../../helpers/random';\n\nconst REFRESH_EVERY = 24 * 60 * 60 * 1000; // 1 day\n//const REFRESH_EVERY_WEEK = 24 * 60 * 60 * 1000 * 7; // 7 days\nconst STATE_VERSION = App.version;\n\nexport type Background = {\n  type: 'color' | 'image' | 'default',\n  blur: boolean,\n  highlightningColor?: string,\n  color?: string,\n  slug?: string,\n};\n\nexport type Theme = {\n  name: 'day' | 'night' | 'system',\n  background: Background\n};\n\nexport type State = {\n  allDialogsLoaded: DialogsStorage['allDialogsLoaded'],\n  pinnedOrders: DialogsStorage['pinnedOrders'],\n  contactsList: number[],\n  updates: Partial<{\n    seq: number,\n    pts: number,\n    date: number\n  }>,\n  filters: FiltersStorage['filters'],\n  maxSeenMsgId: number,\n  stateCreatedTime: number,\n  recentEmoji: string[],\n  topPeersCache: {\n    [type in TopPeerType]?: {\n      peers: MyTopPeer[],\n      cachedTime: number\n    }\n  },\n  recentSearch: number[],\n  version: typeof STATE_VERSION,\n  authState: AuthState,\n  hiddenPinnedMessages: {[peerId: string]: number},\n  settings: {\n    messagesTextSize: number,\n    sendShortcut: 'enter' | 'ctrlEnter',\n    animationsEnabled: boolean,\n    autoDownload: {\n      contacts: boolean\n      private: boolean\n      groups: boolean\n      channels: boolean\n    },\n    autoPlay: {\n      gifs: boolean,\n      videos: boolean\n    },\n    stickers: {\n      suggest: boolean,\n      loop: boolean\n    },\n    emoji: {\n      suggest: boolean,\n      big: boolean\n    },\n    background?: Background, // ! DEPRECATED\n    themes: Theme[],\n    theme: Theme['name'],\n    notifications: {\n      sound: boolean\n    },\n    nightTheme?: boolean, // ! DEPRECATED\n  },\n  keepSigned: boolean,\n  chatContextMenuHintWasShown: boolean,\n  stateId: number\n};\n\nexport const STATE_INIT: State = {\n  allDialogsLoaded: {},\n  pinnedOrders: {},\n  contactsList: [],\n  updates: {},\n  filters: {},\n  maxSeenMsgId: 0,\n  stateCreatedTime: Date.now(),\n  recentEmoji: [],\n  topPeersCache: {},\n  recentSearch: [],\n  version: STATE_VERSION,\n  authState: {\n    _: IS_MOBILE ? 'authStateSignIn' : 'authStateSignQr'\n  },\n  hiddenPinnedMessages: {},\n  settings: {\n    messagesTextSize: 16,\n    sendShortcut: 'enter',\n    animationsEnabled: true,\n    autoDownload: {\n      contacts: true,\n      private: true,\n      groups: true,\n      channels: true\n    },\n    autoPlay: {\n      gifs: true,\n      videos: true\n    },\n    stickers: {\n      suggest: true,\n      loop: true\n    },\n    emoji: {\n      suggest: true,\n      big: true\n    },\n    themes: [{\n      name: 'day',\n      background: {\n        type: 'image',\n        blur: false,\n        slug: 'ByxGo2lrMFAIAAAAmkJxZabh8eM', // * new blurred camomile,\n        highlightningColor: 'hsla(85.5319, 36.9171%, 40.402%, 0.4)'\n      }\n    }, {\n      name: 'night',\n      background: {\n        type: 'color',\n        blur: false,\n        color: '#0f0f0f',\n        highlightningColor: 'hsla(0, 0%, 3.82353%, 0.4)'\n      }\n    }],\n    theme: 'system',\n    notifications: {\n      sound: false\n    }\n  },\n  keepSigned: true,\n  chatContextMenuHintWasShown: false,\n  stateId: nextRandomUint(32)\n};\n\nconst ALL_KEYS = Object.keys(STATE_INIT) as any as Array<keyof State>;\n\nconst REFRESH_KEYS = ['contactsList', 'stateCreatedTime',\n  'maxSeenMsgId', 'filters', 'topPeers'] as any as Array<keyof State>;\n\n//const REFRESH_KEYS_WEEK = ['dialogs', 'allDialogsLoaded', 'updates', 'pinnedOrders'] as any as Array<keyof State>;\n\nexport class AppStateManager extends EventListenerBase<{\n  save: (state: State) => Promise<void>,\n  peerNeeded: (peerId: number) => void,\n  peerUnneeded: (peerId: number) => void,\n}> {\n  public static STATE_INIT = STATE_INIT;\n  private loaded: Promise<State>;\n  private log = logger('STATE'/* , LogLevels.error */);\n\n  private state: State;\n\n  private neededPeers: Map<number, Set<string>> = new Map();\n  private singlePeerMap: Map<string, number> = new Map();\n\n  public storages = {\n    users: new AppStorage<Record<number, User>, typeof DATABASE_STATE>(DATABASE_STATE, 'users'),\n    chats: new AppStorage<Record<number, Chat>, typeof DATABASE_STATE>(DATABASE_STATE, 'chats'),\n    dialogs: new AppStorage<Record<number, Dialog>, typeof DATABASE_STATE>(DATABASE_STATE, 'dialogs')\n  };\n\n  public storagesResults: {\n    users: User[],\n    chats: Chat[],\n    dialogs: Dialog[]\n  } = {} as any;\n\n  public storage = stateStorage;\n\n  constructor() {\n    super();\n    this.loadSavedState();\n  }\n\n  public loadSavedState(): Promise<State> {\n    if(this.loaded) return this.loaded;\n    console.time('load state');\n    this.loaded = new Promise((resolve) => {\n      const storagesKeys = Object.keys(this.storages) as Array<keyof AppStateManager['storages']>;\n      const storagesPromises: Promise<any>[] = storagesKeys.map(key => this.storages[key].getAll());\n\n      const promises/* : Promise<any>[] */ = ALL_KEYS.map(key => stateStorage.get(key))\n      .concat(sessionStorage.get('user_auth'), sessionStorage.get('state_id'))\n      .concat(stateStorage.get('user_auth')) // support old webk format\n      .concat(storagesPromises);\n\n      Promise.all(promises).then(async(arr) => {\n        /* const self = this;\n        const skipHandleKeys = new Set(['isProxy', 'filters', 'drafts']);\n        const getHandler = (path?: string) => {\n          return {\n            get(target: any, key: any) {\n              if(key === 'isProxy') {\n                return true;\n              }\n\n              const prop = target[key];\n\n              if(prop !== undefined && !skipHandleKeys.has(key) && !prop.isProxy && typeof(prop) === 'object') {\n                target[key] = new Proxy(prop, getHandler(path || key));\n                return target[key];\n              }\n              \n              return prop;\n            },\n            set(target: any, key: any, value: any) {\n              console.log('Setting', target, `.${key} to equal`, value, path);\n          \n              target[key] = value;\n\n              // @ts-ignore\n              self.pushToState(path || key, path ? self.state[path] : value, false);\n\n              return true;\n            }\n          };\n        }; */\n\n        let state: State = this.state = {} as any;\n\n        // ! then can't store false values\n        for(let i = 0, length = ALL_KEYS.length; i < length; ++i) {\n          const key = ALL_KEYS[i];\n          const value = arr[i];\n          if(value !== undefined) {\n            // @ts-ignore\n            state[key] = value;\n          } else {\n            this.pushToState(key, copy(STATE_INIT[key]));\n          }\n        }\n\n        arr.splice(0, ALL_KEYS.length);\n\n        // * Read auth\n        let auth = arr.shift() as UserAuth | number;\n        const stateId = arr.shift() as number;\n        const shiftedWebKAuth = arr.shift() as UserAuth | number;\n        if(!auth && shiftedWebKAuth) { // support old webk auth\n          auth = shiftedWebKAuth;\n          const keys: string[] = ['dc', 'server_time_offset', 'xt_instance'];\n          for(let i = 1; i <= 5; ++i) {\n            keys.push(`dc${i}_server_salt`);\n            keys.push(`dc${i}_auth_key`);\n          }\n\n          const values = await Promise.all(keys.map(key => stateStorage.get(key as any)));\n          keys.push('user_auth');\n          values.push(typeof(auth) === 'number' ? {dcID: values[0] || App.baseDcId, date: Date.now() / 1000 | 0, id: auth} as UserAuth : auth);\n\n          let obj: any = {};\n          keys.forEach((key, idx) => {\n            obj[key] = values[idx];\n          });\n\n          await sessionStorage.set(obj);\n        }\n        \n        /* if(!auth) { // try to read Webogram's session from localStorage\n          try {\n            const keys = Object.keys(localStorage);\n            for(let i = 0; i < keys.length; ++i) {\n              const key = keys[i];\n              let value: any;\n              try {\n                value = localStorage.getItem(key);\n                value = JSON.parse(value);\n              } catch(err) {\n                //console.error(err);\n              }\n\n              sessionStorage.set({\n                [key as any]: value\n              });\n            }\n\n            auth = sessionStorage.getFromCache('user_auth');\n          } catch(err) {\n            this.log.error('localStorage import error', err);\n          }\n        } */\n\n        if(auth) {\n          // ! Warning ! DON'T delete this\n          state.authState = {_: 'authStateSignedIn'};\n          rootScope.dispatchEvent('user_auth', typeof(auth) === 'number' ? {dcID: 0, date: Date.now() / 1000 | 0, id: auth} : auth); // * support old version\n        }\n\n        // * Read storages\n        for(let i = 0, length = storagesKeys.length; i < length; ++i) {\n          this.storagesResults[storagesKeys[i]] = arr[i] as any;\n        }\n\n        arr.splice(0, storagesKeys.length);\n\n        if(state.stateId !== stateId) {\n          if(stateId !== undefined) {\n            const preserve: Map<keyof State, State[keyof State]> = new Map([\n              ['authState', undefined],\n              ['stateId', undefined]\n            ]);\n  \n            preserve.forEach((_, key) => {\n              preserve.set(key, copy(state[key]));\n            });\n  \n            state = this.state = copy(STATE_INIT);\n  \n            preserve.forEach((value, key) => {\n              // @ts-ignore\n              state[key] = value;\n            });\n\n            for(const key in this.storagesResults) {\n              this.storagesResults[key as keyof AppStateManager['storagesResults']].length = 0;\n            }\n\n            this.storage.set(state);\n          }\n\n          await sessionStorage.set({\n            state_id: state.stateId\n          });\n        }\n\n        const time = Date.now();\n        if((state.stateCreatedTime + REFRESH_EVERY) < time) {\n          if(DEBUG) {\n            this.log('will refresh state', state.stateCreatedTime, time);\n          }\n\n          const r = (keys: typeof REFRESH_KEYS) => {\n            keys.forEach(key => {\n              this.pushToState(key, copy(STATE_INIT[key]));\n  \n              // @ts-ignore\n              const s = this.storagesResults[key];\n              if(s && s.length) {\n                s.length = 0;\n              }\n            });\n          };\n          \n          r(REFRESH_KEYS);\n\n          /* if((state.stateCreatedTime + REFRESH_EVERY_WEEK) < time) {\n            if(DEBUG) {\n              this.log('will refresh updates');\n            }\n\n            r(REFRESH_KEYS_WEEK);\n          } */\n        }\n        \n        //state = this.state = new Proxy(state, getHandler());\n\n        // * support old version\n        if(!state.settings.hasOwnProperty('theme') && state.settings.hasOwnProperty('nightTheme')) {\n          state.settings.theme = state.settings.nightTheme ? 'night' : 'day';\n          this.pushToState('settings', state.settings);\n        }\n\n        // * support old version\n        if(!state.settings.hasOwnProperty('themes') && state.settings.background) {\n          state.settings.themes = copy(STATE_INIT.settings.themes);\n          const theme = state.settings.themes.find(t => t.name === state.settings.theme);\n          if(theme) {\n            theme.background = state.settings.background;\n            this.pushToState('settings', state.settings);\n          }\n        }\n\n        validateInitObject(STATE_INIT, state, (missingKey) => {\n          // @ts-ignore\n          this.pushToState(missingKey, state[missingKey]);\n        });\n\n        if(state.version !== STATE_VERSION) {\n          this.pushToState('version', STATE_VERSION);\n        }\n\n        // ! probably there is better place for it\n        rootScope.settings = state.settings;\n\n        if(DEBUG) {\n          this.log('state res', state, copy(state));\n        }\n        \n        //return resolve();\n\n        console.timeEnd('load state');\n        resolve(state);\n      }).catch(resolve);\n    });\n\n    return this.loaded;\n  }\n\n  public getState() {\n    return this.state === undefined ? this.loadSavedState() : Promise.resolve(this.state);\n  }\n\n  public setByKey(key: string, value: any) {\n    setDeepProperty(this.state, key, value);\n    rootScope.dispatchEvent('settings_updated', {key, value});\n\n    const first = key.split('.')[0];\n    // @ts-ignore\n    this.pushToState(first, this.state[first]);\n  }\n\n  public pushToState<T extends keyof State>(key: T, value: State[T], direct = true) {\n    if(direct) {\n      this.state[key] = value;\n    }\n\n    this.setKeyValueToStorage(key, value);\n  }\n\n  public setKeyValueToStorage<T extends keyof State>(key: T, value: State[T] = this.state[key]) {\n    this.storage.set({\n      [key]: value\n    });\n  }\n\n  public requestPeer(peerId: number, type: string, limit?: number) {\n    let set = this.neededPeers.get(peerId);\n    if(set && set.has(type)) {\n      return;\n    }\n\n    if(!set) {\n      set = new Set();\n      this.neededPeers.set(peerId, set);\n    }\n\n    set.add(type);\n    this.dispatchEvent('peerNeeded', peerId);\n\n    if(limit !== undefined) {\n      this.keepPeerSingle(peerId, type);\n    }\n  }\n\n  public isPeerNeeded(peerId: number) {\n    return this.neededPeers.has(peerId);\n  }\n\n  public keepPeerSingle(peerId: number, type: string) {\n    const existsPeerId = this.singlePeerMap.get(type);\n    if(existsPeerId && existsPeerId !== peerId && this.neededPeers.has(existsPeerId)) {\n      const set = this.neededPeers.get(existsPeerId);\n      set.delete(type);\n\n      if(!set.size) {\n        this.neededPeers.delete(existsPeerId);\n        this.dispatchEvent('peerUnneeded', existsPeerId);\n      }\n    }\n\n    if(peerId) {\n      this.singlePeerMap.set(type, peerId);\n    } else {\n      this.singlePeerMap.delete(type);\n    }\n  }\n\n  /* public resetState() {\n    for(let i in this.state) {\n      // @ts-ignore\n      this.state[i] = false;\n    }\n    sessionStorage.set(this.state).then(() => {\n      location.reload();\n    });\n  } */\n}\n\n//console.trace('appStateManager include');\n\nconst appStateManager = new AppStateManager();\nMOUNT_CLASS_TO.appStateManager = appStateManager;\nexport default appStateManager;\n"],"sourceRoot":""}